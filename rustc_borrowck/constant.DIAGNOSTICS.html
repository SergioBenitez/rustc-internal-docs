<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `DIAGNOSTICS` constant in crate `rustc_borrowck`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, DIAGNOSTICS">

    <title>rustc_borrowck::DIAGNOSTICS - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc constant">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../rustc_borrowck/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='logo' width='100'></a>
        <p class='location'><a href='index.html'>rustc_borrowck</a></p><script>window.sidebarCurrent = {name: 'DIAGNOSTICS', ty: 'constant', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Constant <a href='index.html'>rustc_borrowck</a>::<wbr><a class="constant" href=''>DIAGNOSTICS</a></span><span class='out-of-band'><span class='since' title='Stable since Rust version '></span><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/rustc_borrowck/lib.rs.html#46' title='goto source code'>[src]</a></span></h1>
<pre class='rust const'>pub const DIAGNOSTICS: <a class="primitive" href="../std/primitive.array.html">[</a><a class="primitive" href="../std/primitive.tuple.html">(</a>&amp;'static <a class="primitive" href="../std/primitive.str.html">str</a>, &amp;'static <a class="primitive" href="../std/primitive.str.html">str</a><a class="primitive" href="../std/primitive.tuple.html">)</a><a class="primitive" href="../std/primitive.array.html">; 10]</a><code> = </code><code>[(&quot;E0373&quot;,
  &quot;\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It\&#39;s most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won\&#39;t disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won\&#39;t let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there\&#39;s no need to worry\nabout safety.\n&quot;),
 (&quot;E0382&quot;,
  &quot;\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\&quot;{}\&quot;, x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust\&#39;s ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nIf we own the type, the easiest way to address this problem is to implement\n`Copy` and `Clone` on it, as shown below. This allows `y` to copy the\ninformation in `x`, while leaving the original version owned by `x`. Subsequent\nchanges to `x` will not be reflected when accessing `y`.\n\n```\n#[derive(Copy, Clone)]\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\&quot;{}\&quot;, x.s);\n}\n```\n\nAlternatively, if we don\&#39;t control the struct\&#39;s definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\&quot;{}\&quot;, x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n&quot;),
 (&quot;E0383&quot;,
  &quot;\nThis error occurs when an attempt is made to partially reinitialize a\nstructure that is currently uninitialized.\n\nFor example, this can happen when a drop has taken place:\n\n```compile_fail,E0383\nstruct Foo {\n    a: u32,\n}\nimpl Drop for Foo {\n    fn drop(&amp;mut self) { /* ... */ }\n}\n\nlet mut x = Foo { a: 1 };\ndrop(x); // `x` is now uninitialized\nx.a = 2; // error, partial reinitialization of uninitialized structure `t`\n```\n\nThis error can be fixed by fully reinitializing the structure in question:\n\n```\nstruct Foo {\n    a: u32,\n}\nimpl Drop for Foo {\n    fn drop(&amp;mut self) { /* ... */ }\n}\n\nlet mut x = Foo { a: 1 };\ndrop(x);\nx = Foo { a: 2 };\n```\n&quot;),
 (&quot;E0387&quot;,
  &quot;\nThis error occurs when an attempt is made to mutate or mutably reference data\nthat a closure has captured immutably. Examples of this error are shown below:\n\n```compile_fail,E0387\n// Accepts a function or a closure that captures its environment immutably.\n// Closures passed to foo will not be able to mutate their closed-over state.\nfn foo&lt;F: Fn()&gt;(f: F) { }\n\n// Attempts to mutate closed-over data. Error message reads:\n// `cannot assign to data in a captured outer variable...`\nfn mutable() {\n    let mut x = 0u32;\n    foo(|| x = 2);\n}\n\n// Attempts to take a mutable reference to closed-over data.  Error message\n// reads: `cannot borrow data mutably in a captured outer variable...`\nfn mut_addr() {\n    let mut x = 0u32;\n    foo(|| { let y = &amp;mut x; });\n}\n```\n\nThe problem here is that foo is defined as accepting a parameter of type `Fn`.\nClosures passed into foo will thus be inferred to be of type `Fn`, meaning that\nthey capture their context immutably.\n\nIf the definition of `foo` is under your control, the simplest solution is to\ncapture the data mutably. This can be done by defining `foo` to take FnMut\nrather than Fn:\n\n```\nfn foo&lt;F: FnMut()&gt;(f: F) { }\n```\n\nAlternatively, we can consider using the `Cell` and `RefCell` types to achieve\ninterior mutability through a shared reference. Our example\&#39;s `mutable`\nfunction could be redefined as below:\n\n```\nuse std::cell::Cell;\n\nfn foo&lt;F: Fn()&gt;(f: F) { }\n\nfn mutable() {\n    let x = Cell::new(0u32);\n    foo(|| x.set(2));\n}\n```\n\nYou can read more about cell types in the API documentation:\n\nhttps://doc.rust-lang.org/std/cell/\n&quot;),
 (&quot;E0388&quot;, &quot;\nE0388 was removed and is no longer issued.\n&quot;),
 (&quot;E0389&quot;,
  &quot;\nAn attempt was made to mutate data using a non-mutable reference. This\ncommonly occurs when attempting to assign to a non-mutable reference of a\nmutable reference (`&amp;(&amp;mut T)`).\n\nExample of erroneous code:\n\n```compile_fail,E0389\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy = FancyNum{ num: 5 };\n    let fancy_ref = &amp;(&amp;mut fancy);\n    fancy_ref.num = 6; // error: cannot assign to data in a `&amp;` reference\n    println!(\&quot;{}\&quot;, fancy_ref.num);\n}\n```\n\nHere, `&amp;mut fancy` is mutable, but `&amp;(&amp;mut fancy)` is not. Creating an\nimmutable reference to a value borrows it immutably. There can be multiple\nreferences of type `&amp;(&amp;mut T)` that point to the same value, so they must be\nimmutable to prevent multiple mutable references to the same value.\n\nTo fix this, either remove the outer reference:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy = FancyNum{ num: 5 };\n\n    let fancy_ref = &amp;mut fancy;\n    // `fancy_ref` is now &amp;mut FancyNum, rather than &amp;(&amp;mut FancyNum)\n\n    fancy_ref.num = 6; // No error!\n\n    println!(\&quot;{}\&quot;, fancy_ref.num);\n}\n```\n\nOr make the outer reference mutable:\n\n```\nstruct FancyNum {\n    num: u8\n}\n\nfn main() {\n    let mut fancy = FancyNum{ num: 5 };\n\n    let fancy_ref = &amp;mut (&amp;mut fancy);\n    // `fancy_ref` is now &amp;mut(&amp;mut FancyNum), rather than &amp;(&amp;mut FancyNum)\n\n    fancy_ref.num = 6; // No error!\n\n    println!(\&quot;{}\&quot;, fancy_ref.num);\n}\n```\n&quot;),
 (&quot;E0595&quot;,
  &quot;\nClosures cannot mutate immutable captured variables.\n\nErroneous code example:\n\n```compile_fail,E0595\nlet x = 3; // error: closure cannot assign to immutable local variable `x`\nlet mut c = || { x += 1 };\n```\n\nMake the variable binding mutable:\n\n```\nlet mut x = 3; // ok!\nlet mut c = || { x += 1 };\n```\n&quot;),
 (&quot;E0596&quot;,
  &quot;\nThis error occurs because you tried to mutably borrow a non-mutable variable.\n\nExample of erroneous code:\n\n```compile_fail,E0596\nlet x = 1;\nlet y = &amp;mut x; // error: cannot borrow mutably\n```\n\nIn here, `x` isn\&#39;t mutable, so when we try to mutably borrow it in `y`, it\nfails. To fix this error, you need to make `x` mutable:\n\n```\nlet mut x = 1;\nlet y = &amp;mut x; // ok!\n```\n&quot;),
 (&quot;E0597&quot;,
  &quot;\nThis error occurs because a borrow was made inside a variable which has a\ngreater lifetime than the borrowed one.\n\nExample of erroneous code:\n\n```compile_fail,E0597\nstruct Foo&lt;\&#39;a&gt; {\n    x: Option&lt;&amp;\&#39;a u32&gt;,\n}\n\nlet mut x = Foo { x: None };\nlet y = 0;\nx.x = Some(&amp;y); // error: `y` does not live long enough\n```\n\nIn here, `x` is created before `y` and therefore has a greater lifetime. Always\nkeep in mind that values in a scope are dropped in the opposite order they are\ncreated. So to fix the previous example, just make the `y` lifetime greater than\nthe `x`\&#39;s one:\n\n```\nstruct Foo&lt;\&#39;a&gt; {\n    x: Option&lt;&amp;\&#39;a u32&gt;,\n}\n\nlet y = 0;\nlet mut x = Foo { x: None };\nx.x = Some(&amp;y);\n```\n&quot;),
 (&quot;E0626&quot;,
  &quot;\nThis error occurs because a borrow in a generator persists across a\nyield point.\n\n```compile_fail,E0626\n# #![feature(generators, generator_trait)]\n# use std::ops::Generator;\nlet mut b = || {\n    let a = &amp;String::new(); // &lt;-- This borrow...\n    yield (); // ...is still in scope here, when the yield occurs.\n    println!(\&quot;{}\&quot;, a);\n};\nb.resume();\n```\n\nAt present, it is not permitted to have a yield that occurs while a\nborrow is still in scope. To resolve this error, the borrow must\neither be \&quot;contained\&quot; to a smaller scope that does not overlap the\nyield or else eliminated in another way. So, for example, we might\nresolve the previous example by removing the borrow and just storing\nthe integer by value:\n\n```\n# #![feature(generators, generator_trait)]\n# use std::ops::Generator;\nlet mut b = || {\n    let a = 3;\n    yield ();\n    println!(\&quot;{}\&quot;, a);\n};\nb.resume();\n```\n\nThis is a very simple case, of course. In more complex cases, we may\nwish to have more than one reference to the value that was borrowed --\nin those cases, something like the `Rc` or `Arc` types may be useful.\n\nThis error also frequently arises with iteration:\n\n```compile_fail,E0626\n# #![feature(generators, generator_trait)]\n# use std::ops::Generator;\nlet mut b = || {\n  let v = vec![1,2,3];\n  for &amp;x in &amp;v { // &lt;-- borrow of `v` is still in scope...\n    yield x; // ...when this yield occurs.\n  }\n};\nb.resume();\n```\n\nSuch cases can sometimes be resolved by iterating \&quot;by value\&quot; (or using\n`into_iter()`) to avoid borrowing:\n\n```\n# #![feature(generators, generator_trait)]\n# use std::ops::Generator;\nlet mut b = || {\n  let v = vec![1,2,3];\n  for x in v { // &lt;-- Take ownership of the values instead!\n    yield x; // &lt;-- Now yield is OK.\n  }\n};\nb.resume();\n```\n\nIf taking ownership is not an option, using indices can work too:\n\n```\n# #![feature(generators, generator_trait)]\n# use std::ops::Generator;\nlet mut b = || {\n  let v = vec![1,2,3];\n  let len = v.len(); // (*)\n  for i in 0..len {\n    let x = v[i]; // (*)\n    yield x; // &lt;-- Now yield is OK.\n  }\n};\nb.resume();\n\n// (*) -- Unfortunately, these temporaries are currently required.\n// See &lt;https://github.com/rust-lang/rust/issues/43122&gt;.\n```\n&quot;)]</code></pre><div class='stability'><div class='stab unstable'><details><summary><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>rustc_private</code>)</summary><p>this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via <code>Cargo.toml</code> instead?</p>
</details></div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "rustc_borrowck";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>