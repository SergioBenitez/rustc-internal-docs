initSidebarItems({"constant":[["FAT_PTR_ADDR","The first half of a fat pointer. - For a trait object, this is the address of the box. - For a slice, this is the base address."],["FAT_PTR_EXTRA","The second half of a fat pointer. - For a trait object, this is the address of the vtable. - For a slice, this is the length."]],"enum":[["Abi","Describes how values of the type are passed by target ABIs, in terms of categories of C types there are ABI rules for."],["Endian","Endianness of the target, which must match cfg(target-endian)."],["FieldPlacement","Describes how the fields of a type are located in memory."],["Integer","Integers, also used for enum discriminants."],["LayoutError",""],["Primitive","Fundamental unit of memory access and layout."],["SizeSkeleton","Type size \"skeleton\", i.e. the only information determining a type's size. While this is conservative, (aside from constant sizes, only pointers, newtypes thereof and null pointer optimized enums are allowed), it is enough to statically check common usecases of transmute."],["Variants",""]],"fn":[["provide",""]],"struct":[["Align","Alignment of a type in bytes, both ABI-mandated and preferred. Each field is a power of two, giving the alignment a maximum value of 2^(2^8 - 1), which is limited by LLVM to a i32, with a maximum capacity of 2^31 - 1 or 2147483647."],["LayoutDetails",""],["Scalar","Information about one scalar component of a Rust type."],["Size","Size of a type in bytes."],["TargetDataLayout","Parsed Data layout for a target, which contains everything needed to compute layouts."],["TyLayout","The details of the layout of a type, alongside the type itself. Provides various type traversal APIs (e.g. recursing into fields)."]],"trait":[["HasDataLayout",""],["HasTyCtxt",""],["LayoutOf",""],["MaybeResult",""]]});