initSidebarItems({"constant":[["BUILTIN_MACROS_CRATE","Virtual crate for builtin macros"],["CRATE_DEF_INDEX","The crate root is always assigned index 0 by the AST Map code, thanks to `NodeCollector::new`."],["DEF_INDEX_HI_START","The start of the \"high\" range of DefIndexes."],["INVALID_CRATE","A CrateNum value that indicates that something is wrong."],["LOCAL_CRATE","Item definitions in the currently-compiled crate would have the CrateNum LOCAL_CRATE in their DefId."],["RESERVED_FOR_INCR_COMP_CACHE","A special CrateNum that we use for the tcx.rcache when decoding from the incr. comp. cache."]],"enum":[["DefIndexAddressSpace",""]],"struct":[["CrateNum",""],["DefId","A DefId identifies a particular definition, by combining a crate index and a def index."],["DefIndex",""],["LocalDefId","A LocalDefId is equivalent to a DefId with `krate == LOCAL_CRATE`. Since we encode this information in the type, we can ensure at compile time that no DefIds from upstream crates get thrown into the mix. There are quite a few cases where we know that only DefIds from the local crate are expected and a DefId from a different crate would signify a bug somewhere. This is when LocalDefId comes in handy."]]});